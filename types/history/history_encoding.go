// Code generated by fastssz. DO NOT EDIT.
// Hash: aa5d2c77e83395d8e8c3999046a6ca0b109e522fa9ff7a12b07db26c9720d559
// Version: 0.1.3
package history

import (
	ssz "github.com/ferranbt/fastssz"
)

// MarshalSSZ ssz marshals the BlockProofHistoricalHashesAccumulator object
func (b *BlockProofHistoricalHashesAccumulator) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BlockProofHistoricalHashesAccumulator object to a target array
func (b *BlockProofHistoricalHashesAccumulator) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Proof'
	if size := len(b.Proof); size != 15 {
		err = ssz.ErrVectorLengthFn("BlockProofHistoricalHashesAccumulator.Proof", size, 15)
		return
	}
	for ii := 0; ii < 15; ii++ {
		if size := len(b.Proof[ii]); size != 32 {
			err = ssz.ErrBytesLengthFn("BlockProofHistoricalHashesAccumulator.Proof[ii]", size, 32)
			return
		}
		dst = append(dst, b.Proof[ii]...)
	}

	return
}

// UnmarshalSSZ ssz unmarshals the BlockProofHistoricalHashesAccumulator object
func (b *BlockProofHistoricalHashesAccumulator) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 480 {
		return ssz.ErrSize
	}

	// Field (0) 'Proof'
	b.Proof = make([][]byte, 15)
	for ii := 0; ii < 15; ii++ {
		if cap(b.Proof[ii]) == 0 {
			b.Proof[ii] = make([]byte, 0, len(buf[0:480][ii*32:(ii+1)*32]))
		}
		b.Proof[ii] = append(b.Proof[ii], buf[0:480][ii*32:(ii+1)*32]...)
	}

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the BlockProofHistoricalHashesAccumulator object
func (b *BlockProofHistoricalHashesAccumulator) SizeSSZ() (size int) {
	size = 480
	return
}

// HashTreeRoot ssz hashes the BlockProofHistoricalHashesAccumulator object
func (b *BlockProofHistoricalHashesAccumulator) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BlockProofHistoricalHashesAccumulator object with a hasher
func (b *BlockProofHistoricalHashesAccumulator) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Proof'
	{
		if size := len(b.Proof); size != 15 {
			err = ssz.ErrVectorLengthFn("BlockProofHistoricalHashesAccumulator.Proof", size, 15)
			return
		}
		subIndx := hh.Index()
		for _, i := range b.Proof {
			if len(i) != 32 {
				err = ssz.ErrBytesLength
				return
			}
			hh.Append(i)
		}
		hh.Merkleize(subIndx)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BlockProofHistoricalHashesAccumulator object
func (b *BlockProofHistoricalHashesAccumulator) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the BlockProofHistoricalRoots object
func (b *BlockProofHistoricalRoots) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BlockProofHistoricalRoots object to a target array
func (b *BlockProofHistoricalRoots) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'BeaconBlockProof'
	if size := len(b.BeaconBlockProof); size != 14 {
		err = ssz.ErrVectorLengthFn("BlockProofHistoricalRoots.BeaconBlockProof", size, 14)
		return
	}
	for ii := 0; ii < 14; ii++ {
		if size := len(b.BeaconBlockProof[ii]); size != 32 {
			err = ssz.ErrBytesLengthFn("BlockProofHistoricalRoots.BeaconBlockProof[ii]", size, 32)
			return
		}
		dst = append(dst, b.BeaconBlockProof[ii]...)
	}

	// Field (1) 'BeaconBlockRoot'
	if size := len(b.BeaconBlockRoot); size != 32 {
		err = ssz.ErrBytesLengthFn("BlockProofHistoricalRoots.BeaconBlockRoot", size, 32)
		return
	}
	dst = append(dst, b.BeaconBlockRoot...)

	// Field (2) 'ExecutionBlockProof'
	if size := len(b.ExecutionBlockProof); size != 11 {
		err = ssz.ErrVectorLengthFn("BlockProofHistoricalRoots.ExecutionBlockProof", size, 11)
		return
	}
	for ii := 0; ii < 11; ii++ {
		if size := len(b.ExecutionBlockProof[ii]); size != 32 {
			err = ssz.ErrBytesLengthFn("BlockProofHistoricalRoots.ExecutionBlockProof[ii]", size, 32)
			return
		}
		dst = append(dst, b.ExecutionBlockProof[ii]...)
	}

	// Field (3) 'Slot'
	dst = ssz.MarshalUint64(dst, b.Slot)

	return
}

// UnmarshalSSZ ssz unmarshals the BlockProofHistoricalRoots object
func (b *BlockProofHistoricalRoots) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 840 {
		return ssz.ErrSize
	}

	// Field (0) 'BeaconBlockProof'
	b.BeaconBlockProof = make([][]byte, 14)
	for ii := 0; ii < 14; ii++ {
		if cap(b.BeaconBlockProof[ii]) == 0 {
			b.BeaconBlockProof[ii] = make([]byte, 0, len(buf[0:448][ii*32:(ii+1)*32]))
		}
		b.BeaconBlockProof[ii] = append(b.BeaconBlockProof[ii], buf[0:448][ii*32:(ii+1)*32]...)
	}

	// Field (1) 'BeaconBlockRoot'
	if cap(b.BeaconBlockRoot) == 0 {
		b.BeaconBlockRoot = make([]byte, 0, len(buf[448:480]))
	}
	b.BeaconBlockRoot = append(b.BeaconBlockRoot, buf[448:480]...)

	// Field (2) 'ExecutionBlockProof'
	b.ExecutionBlockProof = make([][]byte, 11)
	for ii := 0; ii < 11; ii++ {
		if cap(b.ExecutionBlockProof[ii]) == 0 {
			b.ExecutionBlockProof[ii] = make([]byte, 0, len(buf[480:832][ii*32:(ii+1)*32]))
		}
		b.ExecutionBlockProof[ii] = append(b.ExecutionBlockProof[ii], buf[480:832][ii*32:(ii+1)*32]...)
	}

	// Field (3) 'Slot'
	b.Slot = ssz.UnmarshallUint64(buf[832:840])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the BlockProofHistoricalRoots object
func (b *BlockProofHistoricalRoots) SizeSSZ() (size int) {
	size = 840
	return
}

// HashTreeRoot ssz hashes the BlockProofHistoricalRoots object
func (b *BlockProofHistoricalRoots) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BlockProofHistoricalRoots object with a hasher
func (b *BlockProofHistoricalRoots) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'BeaconBlockProof'
	{
		if size := len(b.BeaconBlockProof); size != 14 {
			err = ssz.ErrVectorLengthFn("BlockProofHistoricalRoots.BeaconBlockProof", size, 14)
			return
		}
		subIndx := hh.Index()
		for _, i := range b.BeaconBlockProof {
			if len(i) != 32 {
				err = ssz.ErrBytesLength
				return
			}
			hh.Append(i)
		}
		hh.Merkleize(subIndx)
	}

	// Field (1) 'BeaconBlockRoot'
	if size := len(b.BeaconBlockRoot); size != 32 {
		err = ssz.ErrBytesLengthFn("BlockProofHistoricalRoots.BeaconBlockRoot", size, 32)
		return
	}
	hh.PutBytes(b.BeaconBlockRoot)

	// Field (2) 'ExecutionBlockProof'
	{
		if size := len(b.ExecutionBlockProof); size != 11 {
			err = ssz.ErrVectorLengthFn("BlockProofHistoricalRoots.ExecutionBlockProof", size, 11)
			return
		}
		subIndx := hh.Index()
		for _, i := range b.ExecutionBlockProof {
			if len(i) != 32 {
				err = ssz.ErrBytesLength
				return
			}
			hh.Append(i)
		}
		hh.Merkleize(subIndx)
	}

	// Field (3) 'Slot'
	hh.PutUint64(b.Slot)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BlockProofHistoricalRoots object
func (b *BlockProofHistoricalRoots) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the BlockProofHistoricalSummariesCapella object
func (b *BlockProofHistoricalSummariesCapella) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BlockProofHistoricalSummariesCapella object to a target array
func (b *BlockProofHistoricalSummariesCapella) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'BeaconBlockProof'
	if size := len(b.BeaconBlockProof); size != 13 {
		err = ssz.ErrVectorLengthFn("BlockProofHistoricalSummariesCapella.BeaconBlockProof", size, 13)
		return
	}
	for ii := 0; ii < 13; ii++ {
		if size := len(b.BeaconBlockProof[ii]); size != 32 {
			err = ssz.ErrBytesLengthFn("BlockProofHistoricalSummariesCapella.BeaconBlockProof[ii]", size, 32)
			return
		}
		dst = append(dst, b.BeaconBlockProof[ii]...)
	}

	// Field (1) 'BeaconBlockRoot'
	if size := len(b.BeaconBlockRoot); size != 32 {
		err = ssz.ErrBytesLengthFn("BlockProofHistoricalSummariesCapella.BeaconBlockRoot", size, 32)
		return
	}
	dst = append(dst, b.BeaconBlockRoot...)

	// Field (2) 'ExecutionBlockProof'
	if size := len(b.ExecutionBlockProof); size != 11 {
		err = ssz.ErrVectorLengthFn("BlockProofHistoricalSummariesCapella.ExecutionBlockProof", size, 11)
		return
	}
	for ii := 0; ii < 11; ii++ {
		if size := len(b.ExecutionBlockProof[ii]); size != 32 {
			err = ssz.ErrBytesLengthFn("BlockProofHistoricalSummariesCapella.ExecutionBlockProof[ii]", size, 32)
			return
		}
		dst = append(dst, b.ExecutionBlockProof[ii]...)
	}

	// Field (3) 'Slot'
	dst = ssz.MarshalUint64(dst, b.Slot)

	return
}

// UnmarshalSSZ ssz unmarshals the BlockProofHistoricalSummariesCapella object
func (b *BlockProofHistoricalSummariesCapella) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 808 {
		return ssz.ErrSize
	}

	// Field (0) 'BeaconBlockProof'
	b.BeaconBlockProof = make([][]byte, 13)
	for ii := 0; ii < 13; ii++ {
		if cap(b.BeaconBlockProof[ii]) == 0 {
			b.BeaconBlockProof[ii] = make([]byte, 0, len(buf[0:416][ii*32:(ii+1)*32]))
		}
		b.BeaconBlockProof[ii] = append(b.BeaconBlockProof[ii], buf[0:416][ii*32:(ii+1)*32]...)
	}

	// Field (1) 'BeaconBlockRoot'
	if cap(b.BeaconBlockRoot) == 0 {
		b.BeaconBlockRoot = make([]byte, 0, len(buf[416:448]))
	}
	b.BeaconBlockRoot = append(b.BeaconBlockRoot, buf[416:448]...)

	// Field (2) 'ExecutionBlockProof'
	b.ExecutionBlockProof = make([][]byte, 11)
	for ii := 0; ii < 11; ii++ {
		if cap(b.ExecutionBlockProof[ii]) == 0 {
			b.ExecutionBlockProof[ii] = make([]byte, 0, len(buf[448:800][ii*32:(ii+1)*32]))
		}
		b.ExecutionBlockProof[ii] = append(b.ExecutionBlockProof[ii], buf[448:800][ii*32:(ii+1)*32]...)
	}

	// Field (3) 'Slot'
	b.Slot = ssz.UnmarshallUint64(buf[800:808])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the BlockProofHistoricalSummariesCapella object
func (b *BlockProofHistoricalSummariesCapella) SizeSSZ() (size int) {
	size = 808
	return
}

// HashTreeRoot ssz hashes the BlockProofHistoricalSummariesCapella object
func (b *BlockProofHistoricalSummariesCapella) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BlockProofHistoricalSummariesCapella object with a hasher
func (b *BlockProofHistoricalSummariesCapella) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'BeaconBlockProof'
	{
		if size := len(b.BeaconBlockProof); size != 13 {
			err = ssz.ErrVectorLengthFn("BlockProofHistoricalSummariesCapella.BeaconBlockProof", size, 13)
			return
		}
		subIndx := hh.Index()
		for _, i := range b.BeaconBlockProof {
			if len(i) != 32 {
				err = ssz.ErrBytesLength
				return
			}
			hh.Append(i)
		}
		hh.Merkleize(subIndx)
	}

	// Field (1) 'BeaconBlockRoot'
	if size := len(b.BeaconBlockRoot); size != 32 {
		err = ssz.ErrBytesLengthFn("BlockProofHistoricalSummariesCapella.BeaconBlockRoot", size, 32)
		return
	}
	hh.PutBytes(b.BeaconBlockRoot)

	// Field (2) 'ExecutionBlockProof'
	{
		if size := len(b.ExecutionBlockProof); size != 11 {
			err = ssz.ErrVectorLengthFn("BlockProofHistoricalSummariesCapella.ExecutionBlockProof", size, 11)
			return
		}
		subIndx := hh.Index()
		for _, i := range b.ExecutionBlockProof {
			if len(i) != 32 {
				err = ssz.ErrBytesLength
				return
			}
			hh.Append(i)
		}
		hh.Merkleize(subIndx)
	}

	// Field (3) 'Slot'
	hh.PutUint64(b.Slot)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BlockProofHistoricalSummariesCapella object
func (b *BlockProofHistoricalSummariesCapella) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the BlockProofHistoricalSummariesDeneb object
func (b *BlockProofHistoricalSummariesDeneb) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BlockProofHistoricalSummariesDeneb object to a target array
func (b *BlockProofHistoricalSummariesDeneb) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'BeaconBlockProof'
	if size := len(b.BeaconBlockProof); size != 13 {
		err = ssz.ErrVectorLengthFn("BlockProofHistoricalSummariesDeneb.BeaconBlockProof", size, 13)
		return
	}
	for ii := 0; ii < 13; ii++ {
		if size := len(b.BeaconBlockProof[ii]); size != 32 {
			err = ssz.ErrBytesLengthFn("BlockProofHistoricalSummariesDeneb.BeaconBlockProof[ii]", size, 32)
			return
		}
		dst = append(dst, b.BeaconBlockProof[ii]...)
	}

	// Field (1) 'BeaconBlockRoot'
	if size := len(b.BeaconBlockRoot); size != 32 {
		err = ssz.ErrBytesLengthFn("BlockProofHistoricalSummariesDeneb.BeaconBlockRoot", size, 32)
		return
	}
	dst = append(dst, b.BeaconBlockRoot...)

	// Field (2) 'ExecutionBlockProof'
	if size := len(b.ExecutionBlockProof); size != 12 {
		err = ssz.ErrVectorLengthFn("BlockProofHistoricalSummariesDeneb.ExecutionBlockProof", size, 12)
		return
	}
	for ii := 0; ii < 12; ii++ {
		if size := len(b.ExecutionBlockProof[ii]); size != 32 {
			err = ssz.ErrBytesLengthFn("BlockProofHistoricalSummariesDeneb.ExecutionBlockProof[ii]", size, 32)
			return
		}
		dst = append(dst, b.ExecutionBlockProof[ii]...)
	}

	// Field (3) 'Slot'
	dst = ssz.MarshalUint64(dst, b.Slot)

	return
}

// UnmarshalSSZ ssz unmarshals the BlockProofHistoricalSummariesDeneb object
func (b *BlockProofHistoricalSummariesDeneb) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 840 {
		return ssz.ErrSize
	}

	// Field (0) 'BeaconBlockProof'
	b.BeaconBlockProof = make([][]byte, 13)
	for ii := 0; ii < 13; ii++ {
		if cap(b.BeaconBlockProof[ii]) == 0 {
			b.BeaconBlockProof[ii] = make([]byte, 0, len(buf[0:416][ii*32:(ii+1)*32]))
		}
		b.BeaconBlockProof[ii] = append(b.BeaconBlockProof[ii], buf[0:416][ii*32:(ii+1)*32]...)
	}

	// Field (1) 'BeaconBlockRoot'
	if cap(b.BeaconBlockRoot) == 0 {
		b.BeaconBlockRoot = make([]byte, 0, len(buf[416:448]))
	}
	b.BeaconBlockRoot = append(b.BeaconBlockRoot, buf[416:448]...)

	// Field (2) 'ExecutionBlockProof'
	b.ExecutionBlockProof = make([][]byte, 12)
	for ii := 0; ii < 12; ii++ {
		if cap(b.ExecutionBlockProof[ii]) == 0 {
			b.ExecutionBlockProof[ii] = make([]byte, 0, len(buf[448:832][ii*32:(ii+1)*32]))
		}
		b.ExecutionBlockProof[ii] = append(b.ExecutionBlockProof[ii], buf[448:832][ii*32:(ii+1)*32]...)
	}

	// Field (3) 'Slot'
	b.Slot = ssz.UnmarshallUint64(buf[832:840])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the BlockProofHistoricalSummariesDeneb object
func (b *BlockProofHistoricalSummariesDeneb) SizeSSZ() (size int) {
	size = 840
	return
}

// HashTreeRoot ssz hashes the BlockProofHistoricalSummariesDeneb object
func (b *BlockProofHistoricalSummariesDeneb) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BlockProofHistoricalSummariesDeneb object with a hasher
func (b *BlockProofHistoricalSummariesDeneb) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'BeaconBlockProof'
	{
		if size := len(b.BeaconBlockProof); size != 13 {
			err = ssz.ErrVectorLengthFn("BlockProofHistoricalSummariesDeneb.BeaconBlockProof", size, 13)
			return
		}
		subIndx := hh.Index()
		for _, i := range b.BeaconBlockProof {
			if len(i) != 32 {
				err = ssz.ErrBytesLength
				return
			}
			hh.Append(i)
		}
		hh.Merkleize(subIndx)
	}

	// Field (1) 'BeaconBlockRoot'
	if size := len(b.BeaconBlockRoot); size != 32 {
		err = ssz.ErrBytesLengthFn("BlockProofHistoricalSummariesDeneb.BeaconBlockRoot", size, 32)
		return
	}
	hh.PutBytes(b.BeaconBlockRoot)

	// Field (2) 'ExecutionBlockProof'
	{
		if size := len(b.ExecutionBlockProof); size != 12 {
			err = ssz.ErrVectorLengthFn("BlockProofHistoricalSummariesDeneb.ExecutionBlockProof", size, 12)
			return
		}
		subIndx := hh.Index()
		for _, i := range b.ExecutionBlockProof {
			if len(i) != 32 {
				err = ssz.ErrBytesLength
				return
			}
			hh.Append(i)
		}
		hh.Merkleize(subIndx)
	}

	// Field (3) 'Slot'
	hh.PutUint64(b.Slot)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BlockProofHistoricalSummariesDeneb object
func (b *BlockProofHistoricalSummariesDeneb) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the BlockHeaderWithProof object
func (b *BlockHeaderWithProof) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BlockHeaderWithProof object to a target array
func (b *BlockHeaderWithProof) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(8)

	// Offset (0) 'Header'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.Header)

	// Offset (1) 'Proof'
	dst = ssz.WriteOffset(dst, offset)

	// Field (0) 'Header'
	if size := len(b.Header); size > 8192 {
		err = ssz.ErrBytesLengthFn("BlockHeaderWithProof.Header", size, 8192)
		return
	}
	dst = append(dst, b.Header...)

	// Field (1) 'Proof'
	if size := len(b.Proof); size > 1024 {
		err = ssz.ErrBytesLengthFn("BlockHeaderWithProof.Proof", size, 1024)
		return
	}
	dst = append(dst, b.Proof...)

	return
}

// UnmarshalSSZ ssz unmarshals the BlockHeaderWithProof object
func (b *BlockHeaderWithProof) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 8 {
		return ssz.ErrSize
	}

	tail := buf
	var o0, o1 uint64

	// Offset (0) 'Header'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 != 8 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (1) 'Proof'
	if o1 = ssz.ReadOffset(buf[4:8]); o1 > size || o0 > o1 {
		return ssz.ErrOffset
	}

	// Field (0) 'Header'
	{
		buf = tail[o0:o1]
		if len(buf) > 8192 {
			return ssz.ErrBytesLength
		}
		if cap(b.Header) == 0 {
			b.Header = make([]byte, 0, len(buf))
		}
		b.Header = append(b.Header, buf...)
	}

	// Field (1) 'Proof'
	{
		buf = tail[o1:]
		if len(buf) > 1024 {
			return ssz.ErrBytesLength
		}
		if cap(b.Proof) == 0 {
			b.Proof = make([]byte, 0, len(buf))
		}
		b.Proof = append(b.Proof, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the BlockHeaderWithProof object
func (b *BlockHeaderWithProof) SizeSSZ() (size int) {
	size = 8

	// Field (0) 'Header'
	size += len(b.Header)

	// Field (1) 'Proof'
	size += len(b.Proof)

	return
}

// HashTreeRoot ssz hashes the BlockHeaderWithProof object
func (b *BlockHeaderWithProof) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BlockHeaderWithProof object with a hasher
func (b *BlockHeaderWithProof) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Header'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(b.Header))
		if byteLen > 8192 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(b.Header)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (8192+31)/32)
	}

	// Field (1) 'Proof'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(b.Proof))
		if byteLen > 1024 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(b.Proof)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (1024+31)/32)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BlockHeaderWithProof object
func (b *BlockHeaderWithProof) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the FindContentEphemeralHeadersKey object
func (f *FindContentEphemeralHeadersKey) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(f)
}

// MarshalSSZTo ssz marshals the FindContentEphemeralHeadersKey object to a target array
func (f *FindContentEphemeralHeadersKey) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'BlockHash'
	if size := len(f.BlockHash); size != 32 {
		err = ssz.ErrBytesLengthFn("FindContentEphemeralHeadersKey.BlockHash", size, 32)
		return
	}
	dst = append(dst, f.BlockHash...)

	// Field (1) 'AncestorCount'
	dst = ssz.MarshalUint8(dst, f.AncestorCount)

	return
}

// UnmarshalSSZ ssz unmarshals the FindContentEphemeralHeadersKey object
func (f *FindContentEphemeralHeadersKey) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 33 {
		return ssz.ErrSize
	}

	// Field (0) 'BlockHash'
	if cap(f.BlockHash) == 0 {
		f.BlockHash = make([]byte, 0, len(buf[0:32]))
	}
	f.BlockHash = append(f.BlockHash, buf[0:32]...)

	// Field (1) 'AncestorCount'
	f.AncestorCount = ssz.UnmarshallUint8(buf[32:33])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the FindContentEphemeralHeadersKey object
func (f *FindContentEphemeralHeadersKey) SizeSSZ() (size int) {
	size = 33
	return
}

// HashTreeRoot ssz hashes the FindContentEphemeralHeadersKey object
func (f *FindContentEphemeralHeadersKey) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(f)
}

// HashTreeRootWith ssz hashes the FindContentEphemeralHeadersKey object with a hasher
func (f *FindContentEphemeralHeadersKey) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'BlockHash'
	if size := len(f.BlockHash); size != 32 {
		err = ssz.ErrBytesLengthFn("FindContentEphemeralHeadersKey.BlockHash", size, 32)
		return
	}
	hh.PutBytes(f.BlockHash)

	// Field (1) 'AncestorCount'
	hh.PutUint8(f.AncestorCount)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the FindContentEphemeralHeadersKey object
func (f *FindContentEphemeralHeadersKey) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(f)
}

// MarshalSSZ ssz marshals the OfferEphemeralHeaderKey object
func (o *OfferEphemeralHeaderKey) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(o)
}

// MarshalSSZTo ssz marshals the OfferEphemeralHeaderKey object to a target array
func (o *OfferEphemeralHeaderKey) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'BlockHash'
	if size := len(o.BlockHash); size != 32 {
		err = ssz.ErrBytesLengthFn("OfferEphemeralHeaderKey.BlockHash", size, 32)
		return
	}
	dst = append(dst, o.BlockHash...)

	return
}

// UnmarshalSSZ ssz unmarshals the OfferEphemeralHeaderKey object
func (o *OfferEphemeralHeaderKey) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 32 {
		return ssz.ErrSize
	}

	// Field (0) 'BlockHash'
	if cap(o.BlockHash) == 0 {
		o.BlockHash = make([]byte, 0, len(buf[0:32]))
	}
	o.BlockHash = append(o.BlockHash, buf[0:32]...)

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the OfferEphemeralHeaderKey object
func (o *OfferEphemeralHeaderKey) SizeSSZ() (size int) {
	size = 32
	return
}

// HashTreeRoot ssz hashes the OfferEphemeralHeaderKey object
func (o *OfferEphemeralHeaderKey) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(o)
}

// HashTreeRootWith ssz hashes the OfferEphemeralHeaderKey object with a hasher
func (o *OfferEphemeralHeaderKey) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'BlockHash'
	if size := len(o.BlockHash); size != 32 {
		err = ssz.ErrBytesLengthFn("OfferEphemeralHeaderKey.BlockHash", size, 32)
		return
	}
	hh.PutBytes(o.BlockHash)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the OfferEphemeralHeaderKey object
func (o *OfferEphemeralHeaderKey) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(o)
}

// MarshalSSZ ssz marshals the OfferEphemeralHeader object
func (o *OfferEphemeralHeader) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(o)
}

// MarshalSSZTo ssz marshals the OfferEphemeralHeader object to a target array
func (o *OfferEphemeralHeader) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(4)

	// Offset (0) 'Header'
	dst = ssz.WriteOffset(dst, offset)

	// Field (0) 'Header'
	if size := len(o.Header); size > 2048 {
		err = ssz.ErrBytesLengthFn("OfferEphemeralHeader.Header", size, 2048)
		return
	}
	dst = append(dst, o.Header...)

	return
}

// UnmarshalSSZ ssz unmarshals the OfferEphemeralHeader object
func (o *OfferEphemeralHeader) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 4 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'Header'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 != 4 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (0) 'Header'
	{
		buf = tail[o0:]
		if len(buf) > 2048 {
			return ssz.ErrBytesLength
		}
		if cap(o.Header) == 0 {
			o.Header = make([]byte, 0, len(buf))
		}
		o.Header = append(o.Header, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the OfferEphemeralHeader object
func (o *OfferEphemeralHeader) SizeSSZ() (size int) {
	size = 4

	// Field (0) 'Header'
	size += len(o.Header)

	return
}

// HashTreeRoot ssz hashes the OfferEphemeralHeader object
func (o *OfferEphemeralHeader) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(o)
}

// HashTreeRootWith ssz hashes the OfferEphemeralHeader object with a hasher
func (o *OfferEphemeralHeader) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Header'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(o.Header))
		if byteLen > 2048 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(o.Header)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (2048+31)/32)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the OfferEphemeralHeader object
func (o *OfferEphemeralHeader) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(o)
}
